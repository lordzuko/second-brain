<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Word Embeddings Readings:
Efficient estimation of word representations in vector space. Mikolov et al., NIPS Workshop 2013.
Contextual word representations: A contextual introduction. Smith, 2019. This paper provides a conceptual overview of word embeddings, and explains why contextualized embeddings are an important innovation"><title>Himanshu Maurya</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://lordzuko.github.io/second-brain//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&family=Oswald:wght@700&display=block" rel=stylesheet><link href=https://lordzuko.github.io/second-brain/styles.56d47f5cc6b40c4c97475ab7dab36b03.min.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://lordzuko.github.io/second-brain/js/popover.688c5dcb89a57776d7f1cbeaf6f7c44b.min.js></script>
<script>const BASE_URL="https://lordzuko.github.io/second-brain/",fetchData=Promise.all([fetch("https://lordzuko.github.io/second-brain/indices/linkIndex.87988a113f9da26a245c74dfd4fe9ffb.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://lordzuko.github.io/second-brain/indices/contentIndex.0c87a422af327b9ac82b07a84144e760.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),draw=()=>{const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(draw);e.textContent="",drawGraph("https://lordzuko.github.io/second-brain",[{"/moc":"#4388cc"}],1,!0,!1,!0),initPopover("https://lordzuko.github.io/second-brain",!0,!0),renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},draw()</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://lordzuko.github.io/second-brain/js/search.1d58f2d3eaac68cc50beeb118d91edc9.min.js></script><div class=bodyContent><div class="singlePage logo-background"><header><a class=header_logo href=https://lordzuko.github.io/second-brain/><img src=../../../header.svg alt="Himanshu Maurya"></a><div class=spacer></div><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></header><article><ul class=tags></ul><a href=#word-embeddings><h1 id=word-embeddings><span class=hanchor arialabel=Anchor># </span>Word Embeddings</h1></a><p>Readings:</p><ul><li><p><a target=“_blank” href=https://arxiv.org/abs/1301.3781 rel=noopener>Efficient estimation of word representations in vector space</a>. Mikolov et al., NIPS Workshop 2013.</p></li><li><p><a target=“_blank” href=https://arxiv.org/abs/1902.06006 rel=noopener>Contextual word representations: A contextual</a>
<a target=“_blank” href=https://arxiv.org/abs/1902.06006 rel=noopener>introduction.</a> Smith, 2019. This paper provides a conceptual overview of word embeddings, and explains why contextualized embeddings are an important innovation</p></li><li><p><strong>Pre-training</strong>: train a generic source model (e.g., VGG-16) on a standard, large dataset (e.g., ImageNet). You can think of pre-training as a way of initializing the parameters of your target model to good values.</p></li><li><p><strong>Finetuning</strong>: then take the resulting model, keep its parameters, and replace the output layer to suit the new task. Now train this target model on the dataset for the new task. Transfer learning by finetuning.</p></li></ul><p>While finetuning, keep following things in mind:</p><ul><li><p>we typically have fewer output classes in the finetuning class</p></li><li><p>use smaller learning rate</p></li><li><p>finetune only a handful of layer, while keeping other fixed: <strong>weight freezing</strong></p></li><li><p><strong>source model in finetuning is usually a neural language model</strong>, however the target task is very different from that, as the target task is rarely <strong>Next-Word-Prediction</strong></p></li><li><p>We can all weights of embedding layer for the target model to be trained - this is a limited form of <strong>finetuning.</strong> - We can do full-scale finetuning for NLP, which is possible because of contextualized word embeddings.</p></li><li><p><strong>Static Word Embeddings</strong>:</p><ul><li>Eg: <strong>Word2Vec</strong>, <strong>Glove</strong>, <strong>FastText</strong></li><li>They assign fixed vector to each word; <strong>context independent</strong></li><li>Used for initializing the embedding layers of a target model; i.e. for feature extraction</li><li><strong>Not designed for finetuning</strong></li><li>efficient and can be trained from scratch with humble resources</li></ul></li><li><p><strong>Contextualized Word Embeddings</strong></p><ul><li>Eg: Bert, GPT etc.</li><li>Often called pretrained language model or **LLM (large language models)</li><li>assign a vector to a word that depends on its context: i.e. on its preceding and following words - <strong>context dependent</strong></li><li>can be used in target model to initialize embeddings like static embeddings</li><li><strong>designed to be finetuned</strong> - we re-train some of the weights of the embedding model for the target task.</li><li><strong>requires considerable resources to train from scratch</strong>; finetuning is efficient way of using them</li></ul></li></ul><a href=#static-word-embeddings><h1 id=static-word-embeddings><span class=hanchor arialabel=Anchor># </span>Static Word Embeddings</h1></a><ul><li><p><strong>Word2Vec : Continuous Bag-of-words model (CBOW)</strong></p></li><li></li><li><p><strong>CBOW</strong>: uses words within a context window to predict the current word (5 window size is used)</p></li><li><p>architecture:</p><ul><li>has only a single, linear hidden layer</li><li>Weights for differnt position are shared</li></ul></li><li><p><strong>Word2Vec: Skipgram</strong></p></li><li></li><li><p><strong>Skipgram:</strong> uses the current word to predict the context words</p></li><li><p>architecture:</p><ul><li>flipped version of CBOW</li></ul></li><li><p><strong>Details:</strong></p><ul><li><p>Objective function maximizes the probability of the corpus D (set of all word and context pairs extracted from text):</p><ul><li><p>$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  \arg\max_\theta \prod_{(w,c) \epsilon D} p(c|w;\theta)
</span></span></code></pre></td></tr></table></div></div></li></ul><p>$$</p></li><li><p>Here: $p(c|w;\theta)$ is defined as:
$$
p(c|w;\theta) = \frac{exp(v_c . v_w)}{\sum_{c^<code> \epsilon C}exp(V_{c^</code>} . v_w)}
$$</p></li><li><p>$v_c$, $v_w$ are vector representation of $c$ and $w$ and $C$ is the set of all available contexts</p></li><li><p>$W$ - word vocabulary</p></li><li><p>$C$ - Context vocabulary</p></li><li><p>$d$ - embedding dim</p></li><li><p>each $w \epsilon W$ is associated with vector $v_w \epsilon \mathbb{R}^d$</p></li><li><p>each $c \epsilon C$ is associated with vector $v_c \epsilon \mathbb{R}^d$</p></li><li><p>NOTE: the formulation is impractical due to $\sum_{c^<code> \epsilon C}exp(V_{c^</code>} . v_w)$ over all context $c^`$ . This makes the softmax too expensive to compute for large vocabulary. Negative sampling helps us make the sum tractable.</p></li></ul></li><li><p><strong>Negative Sampling</strong></p><ul><li>Check if you have time:
<a target=“_blank” href=https://arxiv.org/pdf/1402.3722.pdf rel=noopener>word2vec Explained: Deriving Mikolov et al.’s Negative-Sampling Word-Embedding Method</a> - has the derivation of negative sampling objective and good information on skip-gram model.</li><li>The idea is to not evaluate the full output layer based on the hidden layer.<ul><li>Treat this as independent logistic regression classifiers (i.e. <strong>replace softmax objective with a binary classification objective</strong>)<ul><li>The model is trained to distinguish<ul><li>the positive class / <strong>target word</strong></li><li>a few randomly sampled neurons or <strong>randomly sampled negative words</strong></li></ul></li><li>This make training speech independent of vocabulary size and this can be parallelized</li></ul></li></ul></li></ul></li><li><p><strong>Detailed derivation of Negative sampling Objective:</strong></p></li></ul><p>Consider a pair $(w, c)$ of word and context. Did this pair come from the training data? Let’s denote by $p(D = 1|w, c)$ the probability that (w, c) came from the corpus data. Correspondingly, $p(D = 0|w, c) = 1 − p(D = 1|w, c)$ will be the probability that $(w, c)$ did not come from the corpus data. As before, assume there are parameters θ controlling the distribution: $p(D = 1|w, c; θ)$.</p><p>$$
\begin{align}
&\quad \arg\max_{\theta} \prod_{(w,c)\in D} p(D=1|w,c;\theta)\\&\quad = \arg\max_{\theta} \log \prod_{(w,c)\in D} p(D=1|w,c;\theta)\\&\quad = \arg\max_{\theta} \sum_{(w,c)\in D} \log p(D=1|w,c;\theta)
\end{align}
$$
where $p(D=1|w,c;\theta)$ can be defined using softmax:
$$ \begin{align}</p><p>&\quad p(D=1|w,c;\theta) = \frac{1}{1+e^{-v_c \cdot v_w}} \\\end{align}
$$
Leading to the objective:
$$\begin{align}
&\quad \Rightarrow \arg\max_{\theta} \sum_{(w,c)\in D} \log \frac{1}{1+e^{-v_c \cdot v_w}}
\end{align}
$$
This objective has a trivial solution if we set $θ$ such that $p(D = 1|w, c; θ) = 1$ for every pair $(w, c)$. This can be easily achieved by setting θ such that $v_c = v_w$ and $v_c · v_w = K$ for all $v_c$, vw , where K is large enough number (practically, we get a probability of 1 as soon as $K ≈ 40)$.<br>We need a mechanism that prevents all the vectors from having the same value, by disallowing some $(w, c)$ combinations. One way to do so, is to present the model with some $(w, c)$ pairs for which $p(D = 1|w, c; θ)$ must be low, i.e. pairs which are not in the data. This is achieved by generating the set $D^′$ of random $(w, c)$ pairs, assuming they are all incorrect (the name “negative-sampling” stems from the set $D^′$ of randomly sampled negative examples). The optimization objective now becomes:</p><p>$$
\begin{align}
&\quad= \arg\max_{\theta} \prod_{(w,c)\in D} p(D=1|c,w;\theta) \prod_{(w,c)\in D&rsquo;} (1 - p(D=1|c,w;\theta)) \\&\quad= \arg\max_{\theta} \prod_{(w,c)\in D} p(D=1|c,w;\theta) \prod_{(w,c)\in D&rsquo;} (1 - p(D=1|c,w;\theta)) \\&\quad= \arg\max_{\theta} \sum_{(w,c)\in D} \log p(D=1|c,w;\theta) + \sum_{(w,c)\in D&rsquo;} \log(1-p(D=1|w,c;\theta)) \\&\quad= \arg\max_{\theta} \sum_{(w,c)\in D} \log \frac{1}{1+e^{-v_c\cdot v_w}} + \sum_{(w,c)\in D&rsquo;} \log \frac{1}{1+e^{v_c\cdot v_w}} \\&\quad= \arg\max_{\theta} \sum_{(w,c)\in D} \log \frac{1}{1+e^{-v_c\cdot v_w}} + \sum_{(w,c)\in D&rsquo;} \log \frac{1}{1+e^{v_c\cdot v_w}}
\end{align}
$$</p><p>If we let $σ(x) = \frac{1}{1+e^{−x}}$ we get:
$$
\begin{align}
&\quad
\arg\max_{\theta} \sum_{(w,c)\in D} \log \frac{1}{1+e^{-v_c\cdot v_w}} + \sum_{(w,c)\in D&rsquo;} \log \frac{1}{1+e^{v_c\cdot v_w}} \\&\quad= \arg\max_{\theta} \sum_{(w,c)\in D} \log \sigma(v_c\cdot v_w) + \sum_{(w,c)\in D&rsquo;} \log \sigma(-v_c\cdot v_w)
\end{align}
$$
This is similar to what we have in Mikolov&rsquo;s paper, however they assume $D^\cdot \epsilon D$ . i.e. the $(w,c)$ negative samples are taken from the dataset itself. hence their equation is</p><p>$$
\arg\max_{\theta} \sum_{(w,c)\in D} \log p(c|w) = \sum_{(w,c)\in D} \left( \log e^{v_c\cdot v_w} - \log \sum_{c&rsquo;} e^{v_{c&rsquo;}\cdot v_w} \right)
$$</p><hr><blockquote><p><strong>why does CBOW do better on syntactic tasks, given that word position isn&rsquo;t a factor, and skip-gram do better on semantic tasks?</strong></p></blockquote><p>Some types of syntactic tasks may not require, long-term context information or word order information, let&rsquo;s take these examples:</p><ol><li><p>&ldquo;The dogs chase the cat&rdquo;</p></li><li><p>&ldquo;The big dog barks&rdquo;</p></li><li><p>&ldquo;The dog that chases the cat barks loudly&rdquo;</p></li></ol><p>In case 1) the relationship between the word &ldquo;dogs&rdquo; is in the local context of the verb &ldquo;chase&rdquo;, and the verb can be inferred to be in the plural form to match the subject.</p><p>In case 2) the word &ldquo;dog&rdquo; is in the local context of the adjective &ldquo;big&rdquo;, and the adjective can be inferred to be in the singular masculine form to match the noun.</p><p>Now, given that word order information is not present in CBOW, this grammatical information may be inferred indirectly from the distributional semantics of the words which often occur together. Maybe because some tasks such as subject-verb agreement or noun-adjective agreement, can be performed based on local context without positional information, CBOW learns to focus on the syntactic properties instead of semantic relations between words. (<em>Neural network has a tendency to take shortcuts</em>).</p><p>However, in case 3) where the agreement relationship is more complex or depends on longer-range dependencies, positional information may be necessary to capture the relationship accurately. In this case, CBOW may not perform well and skip-gram which better captures semantic relationships may serve better.</p><p>now; why does skip-gram do better on semantic tasks?</p><p>It is probably because of the architecture; skip-gram predicts the neighbouring words, which requires more semantic information. By predicting the context words based on the target word, skip-gram is able to capture broader semantic relationships between words that may not be captured by CBOW.</p><p>Hopefully, this helps.</p><p>This is also a good answer on SO:
<a target=“_blank” href=https://ai.stackexchange.com/a/18637 rel=noopener>https://ai.stackexchange.com/a/18637</a> if you want to check out.</p><hr><a href=#pretrained-language-models><h1 id=pretrained-language-models><span class=hanchor arialabel=Anchor># </span>Pretrained Language Models</h1></a><p>Readings:</p><ul><li><p><a target=“_blank” href=https://arxiv.org/abs/1810.04805 rel=noopener>BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a>. Devlin et al., NAACL 2019.</p></li><li><p>Using transformers, we can build language models that represent context very well: <strong>contextualized embeddings</strong>.</p></li><li><p>These language models can be <strong>used for feature extraction</strong>, but also in a <strong>pre-training/finetuning setup</strong>.</p></li></ul><h3 id=bert-httpsaclanthologyorgn19-1423pdf><a target=“_blank” href=https://aclanthology.org/N19-1423.pdf rel=noopener>Bert</a></h3><ul><li><p>Bert (Bidirectional Encoder Representation from Transformer)</p></li><li><p><strong>Purpose</strong> :</p><ul><li><strong>designed for pre-training</strong> deep bidirectional representations from unlabeled text;</li><li><strong>conditions on left and right context</strong> in all layers;</li><li>pre-trained model can be <strong>finetuned with one additional output layer for many tasks</strong> (e.g., NLI, QA, sentiment);</li><li>for many tasks, no modifications to the Bert architecture are required;</li></ul></li><li><p><strong>Architecture</strong>:</p><ul><li>Uses bidirectional representation - i.e. <strong>uses the left and right context both</strong><ul><li>In contrast:<ul><li>GPT - uses only left-to-right context only (unidirectional)</li><li>ELMO - uses shallow concatenation of independently trained left-to-right and right-to-left LSTMs</li></ul></li></ul></li><li><strong>Input / Output Representation</strong>:<ul><li><strong>Input sequence:</strong> can be &lt;Question, Answer> pair, single sentence, or any other string of tokens;</li><li><strong>Token Types:</strong><ul><li>30,000 token vocabulary, represented as <strong>WordPiece embeddings</strong> (handles OOV words);</li><li>first token is always [<strong>CLS</strong>]: aggregate sentence representation for classification tasks;</li><li>sentence pairs separated by [<strong>SEP</strong>] token; and by <strong>segment embeddings</strong>;<ul><li><strong>segment embedding</strong>: segment embeddings are identical across all sub-words of a segment and only differ if input strings containing multiple segments are fed into the model simultaneously (e.g. an input containing two sentences separated by a [SEP] token).</li><li>the intuition behind segment embeddings is less obvious, especially for unsegmented (i.e. single sentence) input<ul><li>While absent in the original Transformer, <strong>BERT further adds segment embeddings to the non-contextualized input representation</strong>. In practice, this means that the input is combined with a sequence of segment IDs (a lookup of the sequence “0 0 &mldr; 0 1 &mldr; 1 1” ), which are found in a lookup table of size 2 × embedding dimensionality (768 in BERTbase).</li><li>Actually gets applied for the NSP task. Two sentences are fed as input to BERT and the model is asked to discriminate usbetween the true next sentence and a randomly sampled alternative sentence occurring 50% of the time. For this task, it is important for the model to be able to distinguish between the two input sentences, hence segment embeddings are used.</li></ul></li><li><a target=“_blank” href=https://aclanthology.org/2022.lrec-1.152.pdf rel=noopener>https://aclanthology.org/2022.lrec-1.152.pdf</a></li></ul></li><li>token position represented by <strong>position embeddings</strong>.</li></ul></li></ul></li></ul></li><li><p><strong>Pretraining and Finetuning approaches</strong>:</p><ul><li><p>The main reason why Bert is famous - Pretraining-Finetuning (though GPT can also be used in the same way)</p></li><li><p><strong>Pre-training BERT</strong>:</p><ul><li><p><strong>Task1: Masked LM</strong></p><ul><li><strong>Try to predict the masked-tokens (this is simlar to skip-gram, where we predict the surrounding words)</strong></li><li>We simply <strong>mask some percentage of the input tokens at random</strong>, and then predict those masked tokens. We refer to this procedure as a “masked LM” (MLM), although it is often referred to as a <strong>Cloze task</strong> in the literature.</li><li>mask 15% of the tokens in the input sequence; train the model to predict these using the context word<ul><li>This however creates a mismatch between pre-training and fine-tuning, since the [MASK] token does not appear during fine-tuning.<ul><li>do not always replace masked words with [MASK], instead choose 15% of token positions at random for prediction;<ul><li>if $i^{th}$ token is chosen, we replace the $i^{th}$ token with:<ol><li>the [MASK] token 80% of the time;</li><li>a random token 10% of the time;</li><li>the unchanged $i^{th}$ token 10% of the time.</li></ol></li></ul></li></ul></li><li>Now use $T_i$ to predict original token with cross entropy loss.</li></ul></li></ul></li><li><p><strong>Task2: Next Sentence Prediction (NSP)</strong></p><ul><li>Tasks like Question-Answering (QA) and NLI are based on relationship b/w two sentences, which is not directly captured by language modeling.</li><li>Solution: Pre-train for a binarized NSP task; trivially this can be generated on any monolingual corpus. If we have two sentences $A$ and $B$ such that $B$ follows $A$<ul><li>50% of the time $B$ is the actual next setence.</li><li>50% of the time $B$ is a random sentence from the corpus.</li></ul></li></ul></li></ul></li><li><p>Pretraining-Finetuning can be understood as:</p><ul><li>(1) sentence pairs in <strong>paraphrasing</strong>,</li><li>(2) hypothesis-premise pairs in <strong>entailment</strong>,</li><li>(3) question-passage pairs in <strong>question answering</strong></li><li>(4) a degenerate $text-∅$ pair in text classification or <strong>sequence tagging</strong>.</li></ul></li><li><p>Token Level Task v/s Full sentence task:</p><ul><li><strong>Token Level:</strong><ul><li>At the output, the token representations are fed into an output layer for token-level tasks, such as <strong>sequence tagging</strong> (eg: NER, POS) or <strong>question answering</strong> (predicts span),</li></ul></li><li><strong>Sentence Level:</strong><ul><li>the $[CLS]$ representation is fed into an output layer for classification, such as <strong>entailment</strong> or <strong>sentiment analysis</strong> (predict class label)</li></ul></li></ul></li></ul></li></ul></article></div><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://lordzuko.github.io/second-brain/js/graph.5388a070919094961d3e5151252e9065.js></script></div></div><div class=footer><div class=outreach><h3>Have a question?</h3><p>Reach out via <strong><a href=mailto:himanshumaurya2214225@gmail.com target=_blank>Email</a></strong> or
<strong><a href=https://twitter.com/lordzuko2 target=_blank>Twitter</a></strong>.</p><p>If you liked the post, <a href="https://twitter.com/intent/tweet?url=https%3a%2f%2flordzuko.github.io%2fsecond-brain%2fUoE%2fNLU%2fWeek4%2f&text=&via=lordzuko2" target=_blank>click here to share it with your friends on Twitter</a>.<br>I ♥️ hearing when the post was
helpful. It makes me smile 😄.</p></div><div id=contact_buttons><footer><p>Made with ♥ in Edinburgh, Scotland, UK<br>© 26262 Himanshu Maurya</p><ul><li><a href=https://twitter.com/lordzuko2 target=_blank>Twitter</a></li><li><a href=https://www.youtube.com/@HimanshuMauryalordzuko target=_blank>YouTube</a></li><li><a href=https://github.com/lordzuko target=_blank>Github</a></li></ul></footer></div></div></div></body></html>